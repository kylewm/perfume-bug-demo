{"version":3,"file":"perfume.min.js","sources":["../src/config.ts","../src/constants.ts","../src/isSupported.ts","../src/getNetworkInformation.ts","../src/isLowEnd.ts","../src/onVisibilityChange.ts","../src/utils.ts","../src/vitalsScore.ts","../src/reportPerf.ts","../src/getNavigatorInfo.ts","../src/log.ts","../src/metrics.ts","../src/cumulativeLayoutShift.ts","../src/observeInstances.ts","../src/performanceObserver.ts","../src/firstInput.ts","../src/totalBlockingTime.ts","../src/paint.ts","../src/resourceTiming.ts","../src/observe.ts","../src/storageEstimate.ts","../src/perfume.ts","../src/getNavigationTiming.ts","../src/measure.ts"],"sourcesContent":["import { IPerfumeConfig } from './types';\n\nexport const config: IPerfumeConfig = {\n  // Metrics\n  isResourceTiming: false,\n  isElementTiming: false,\n  // Logging\n  maxTime: 15000,\n};\n","// Have private variable outside the class,\n// helps drastically reduce the library size\nexport const W = window;\nexport const C = W.console;\nexport const D = document;\nexport const WN = W.navigator;\nexport const WP = W.performance;\nexport const getDM = () => (WN as any).deviceMemory;\nexport const getHC = () => (WN as any).hardwareConcurrency;\n","import { W, WP } from './constants';\n\n/**\n * True if the browser supports the Navigation Timing API,\n * User Timing API and the PerformanceObserver Interface.\n * In Safari, the User Timing API (performance.mark()) is not available,\n * so the DevTools timeline will not be annotated with marks.\n * Support: developer.mozilla.org/en-US/docs/Web/API/Performance/mark\n * Support: developer.mozilla.org/en-US/docs/Web/API/PerformanceObserver\n * Support: developer.mozilla.org/en-US/docs/Web/API/Performance/getEntriesByType\n */\nexport const isPerformanceSupported = (): boolean => {\n  return WP && !!WP.getEntriesByType && !!WP.now && !!WP.mark;\n};\n","import { WN } from './constants';\nimport { EffectiveConnectionType, IPerfumeNetworkInformation } from './types';\n\nexport let et: EffectiveConnectionType = '4g';\nexport let sd = false;\n\nexport const getNetworkInformation = (): IPerfumeNetworkInformation => {\n  if ('connection' in WN) {\n    const dataConnection = (WN as any).connection;\n    if (typeof dataConnection !== 'object') {\n      return {};\n    }\n    et = dataConnection.effectiveType;\n    sd = !!dataConnection.saveData;\n    return {\n      downlink: dataConnection.downlink,\n      effectiveType: dataConnection.effectiveType,\n      rtt: dataConnection.rtt,\n      saveData: !!dataConnection.saveData,\n    };\n  }\n  return {};\n};\n","import { getDM, getHC } from './constants';\nimport { EffectiveConnectionType } from './types';\n\nexport const getIsLowEndDevice = (): boolean => {\n  // If number of logical processors available to run threads <= 4\n  if (getHC() && getHC() <= 4) {\n    return true;\n  }\n  // If the approximate amount of RAM client device has <= 4\n  if (getDM() && getDM() <= 4) {\n    return true;\n  }\n  return false;\n};\n\nexport const getIsLowEndExperience = (\n  et: EffectiveConnectionType,\n  sd: boolean,\n): boolean => {\n  if (getIsLowEndDevice()) {\n    return true;\n  }\n  // If the effective type of the connection meaning\n  // one of 'slow-2g', '2g', '3g', or '4g' is !== 4g\n  if (['slow-2g', '2g', '3g'].includes(et)) {\n    return true;\n  }\n  // Data Saver preference\n  if (sd) {\n    return true;\n  }\n  return false;\n};\n","import { D } from './constants';\n\nexport const visibility = {\n  isHidden: false,\n};\n\n/**\n * From visibilitychange listener it saves only when\n * the page gets hidden, because it's important to not\n * use the wrong \"hidden\" value when send timing or logging.\n */\nexport const didVisibilityChange = function(cb: Function) {\n  if (D.hidden) {\n    cb();\n    visibility.isHidden = D.hidden;\n  }\n};\n","import { W } from './constants';\n\nexport const roundByTwo = (num: number) => {\n  return parseFloat(num.toFixed(2));\n}\n\nexport const convertToKB = (bytes: number): number | null => {\n  if (typeof bytes !== 'number') {\n    return null;\n  }\n  return roundByTwo(bytes / Math.pow(1024, 2));\n};\n\n/**\n * PushTask to requestIdleCallback\n */\nexport const pushTask = (cb: any): void => {\n  if ('requestIdleCallback' in W) {\n    (W as any).requestIdleCallback(cb, { timeout: 3000 });\n  } else {\n    cb();\n  }\n};\n","import { IPerfumeData, IVitalsScore } from './types';\n\nconst fcpScore = [1000, 2500];\nconst lcpScore = [2500, 4000];\nconst fidcore = [100, 300];\nconst clsScore = [0.1, 0.25];\nconst tbtScore = [300, 600];\n\nexport const webVitalsScore: Record<string, number[]> = {\n  fp: fcpScore,\n  fcp: fcpScore,\n  lcp: lcpScore,\n  lcpFinal: lcpScore,\n  fid: fidcore,\n  fidVitals: fidcore,\n  cls: clsScore,\n  clsFinal: clsScore,\n  tbt: tbtScore,\n  tbt5S: tbtScore,\n  tbt10S: tbtScore,\n  tbtFinal: tbtScore,\n};\n\nexport const getVitalsScore = (\n  measureName: string,\n  value: IPerfumeData,\n): IVitalsScore => {\n  if (!webVitalsScore[measureName]) {\n    return null;\n  }\n  if (value <= webVitalsScore[measureName][0]) {\n    return 'good';\n  }\n  return value <= webVitalsScore[measureName][1] ? 'needsImprovement' : 'poor';\n};\n","import { config } from './config';\nimport { getNavigatorInfo } from './getNavigatorInfo';\nimport { visibility } from './onVisibilityChange';\nimport { pushTask } from './utils';\nimport { getVitalsScore } from './vitalsScore';\n\n/**\n * Sends the User timing measure to analyticsTracker\n */\nexport const reportPerf = function(\n  measureName: string,\n  data: any,\n  customProperties?: object,\n): void {\n  pushTask(() => {\n    // Doesn't send timing when page is hidden\n    if (\n      (visibility.isHidden && measureName.indexOf('Final') < 0) ||\n      !config.analyticsTracker\n    ) {\n      return;\n    }\n    // Send metric to custom Analytics service\n    config.analyticsTracker({\n      metricName: measureName,\n      data,\n      eventProperties: customProperties || {},\n      navigatorInformation: getNavigatorInfo(),\n      vitalsScore: getVitalsScore(measureName, data),\n    });\n  });\n};\n","import { getDM, getHC, WN } from './constants';\nimport { et, sd } from './getNetworkInformation';\nimport { getIsLowEndDevice, getIsLowEndExperience } from './isLowEnd';\nimport { INavigatorInfo } from './types';\n\n/**\n * Information coming from window.navigator:\n * 1. Device Memory\n * 2. Hardware Concurency\n * 3. Status of the service worker:\n *     - controlled: a service worker is controlling the page\n *     - supported: the browser supports service worker\n *     - unsupported: the user's browser does not support service worker\n */\nexport const getNavigatorInfo = function(): INavigatorInfo {\n  if (WN) {\n    return {\n      deviceMemory: getDM() || 0,\n      hardwareConcurrency: getHC() || 0,\n      serviceWorkerStatus:\n        'serviceWorker' in WN\n          ? WN.serviceWorker.controller\n            ? 'controlled'\n            : 'supported'\n          : 'unsupported',\n      isLowEndDevice: getIsLowEndDevice(),\n      isLowEndExperience: getIsLowEndExperience(et, sd)\n    };\n  }\n  return {};\n};\n","import { config } from './config';\nimport { reportPerf } from './reportPerf';\nimport { roundByTwo } from './utils';\n\nexport const logData = (\n  measureName: string,\n  metric: any,\n  customProperties?: object,\n): void => {\n  Object.keys(metric).forEach(key => {\n    if (typeof metric[key] === 'number') {\n      metric[key] = roundByTwo(metric[key]);\n    }\n  });\n  // Sends the metric to an external tracking service\n  reportPerf(measureName, metric, customProperties);\n};\n\n/**\n * Dispatches the metric duration into internal logs\n * and the external time tracking service.\n */\nexport const logMetric = (duration: number, measureName: string, customProperties?: object): void => {\n  const duration2Decimal = roundByTwo(duration);\n  if (duration2Decimal <= config.maxTime && duration2Decimal >= 0) {\n    // Sends the metric to an external tracking service\n    reportPerf(measureName, duration2Decimal, customProperties);\n  }\n};\n","import { IMetricMap, IPerfumeDataConsumption } from './types';\n\nexport const metrics: IMetricMap = {};\nexport const cls = {\n  value: 0,\n};\nexport const fcp = {\n  value: 0,\n};\nexport const lcp = {\n  value: 0,\n};\nexport const fcpEntryName = 'first-contentful-paint';\nexport const rt: { value: IPerfumeDataConsumption } = {\n  value: {\n    beacon: 0,\n    css: 0,\n    fetch: 0,\n    img: 0,\n    other: 0,\n    script: 0,\n    total: 0,\n    xmlhttprequest: 0,\n  },\n};\nexport const tbt = {\n  value: 0,\n};\n","import { cls } from './metrics';\nimport { IPerformanceEntry } from './types';\n\n/**\n * Detects new layout shift occurrences and updates the\n * `cumulativeLayoutShiftScore` variable.\n */\nexport const initLayoutShift = (performanceEntries: IPerformanceEntry[]) => {\n  const lastEntry = performanceEntries.pop();\n  // Only count layout shifts without recent user input.\n  if (lastEntry && !lastEntry.hadRecentInput && lastEntry.value) {\n    cls.value += lastEntry.value;\n  }\n};\n","import { IPerfObservers } from './types';\n\nexport const perfObservers: IPerfObservers = {};\n","import { C } from './constants';\nimport { perfObservers } from './observeInstances';\nimport { IPerformanceObserverType } from './types';\n\n/**\n * PerformanceObserver subscribes to performance events as they happen\n * and respond to them asynchronously.\n */\nexport const po = (\n  eventType: IPerformanceObserverType,\n  cb: (performanceEntries: any[]) => void,\n): PerformanceObserver | null => {\n  try {\n    const perfObserver = new PerformanceObserver(entryList => {\n      cb(entryList.getEntries());\n    });\n    // Retrieve buffered events and subscribe to newer events for Paint Timing\n    perfObserver.observe({ type: eventType, buffered: true });\n    return perfObserver;\n  } catch (e) {\n    C.warn('Perfume.js:', e);\n  }\n  return null;\n};\n\nexport const poDisconnect = (observer: any) => {\n  if (perfObservers[observer]) {\n    perfObservers[observer].disconnect();\n  }\n  delete perfObservers[observer];\n}\n","import { logData, logMetric } from './log';\nimport { cls, lcp, rt, tbt } from './metrics';\nimport { perfObservers } from './observeInstances';\nimport { poDisconnect } from './performanceObserver';\nimport { PerformanceEventTiming } from './types';\n\nexport const initFirstInputDelay = (\n  performanceEntries: PerformanceEventTiming[],\n) => {\n  const lastEntry = performanceEntries.pop();\n  if (lastEntry) {\n    // Core Web Vitals FID logic\n    // Measure the delay to begin processing the first input event\n    logMetric(lastEntry.processingStart - lastEntry.startTime, 'fidVitals', {\n      performanceEntry: lastEntry\n    });\n    // Legacy FID logic\n    // Measure the duration of processing the first input event\n    logMetric(lastEntry.duration, 'fid', {\n      performanceEntry: lastEntry\n    });\n  }\n  // Disconnect this observer since callback is only triggered once\n  poDisconnect(1);\n  logMetric(lcp.value, 'lcp');\n  if (perfObservers[3] && typeof perfObservers[3].takeRecords === 'function') {\n    perfObservers[3].takeRecords();\n  }\n  logMetric(cls.value, 'cls');\n  logMetric(tbt.value, 'tbt');\n  // TBT with 5 second delay after FID\n  setTimeout(() => {\n    logMetric(tbt.value, `tbt5S`);\n  }, 5000);\n  // TBT with 10 second delay after FID\n  setTimeout(() => {\n    logMetric(tbt.value, `tbt10S`);\n    logData('dataConsumption', rt.value);\n  }, 10000);\n};\n","import { fcp, tbt } from './metrics';\nimport { IPerformanceEntry } from './types';\n\nexport const initTotalBlockingTime = (\n  performanceEntries: IPerformanceEntry[],\n): void => {\n  performanceEntries.forEach(entry => {\n    if (\n      entry.name !== 'self' ||\n      entry.startTime < fcp.value\n    ) {\n      return;\n    }\n    const blockingTime = entry.duration - 50;\n    if (blockingTime > 0) {\n      tbt.value += blockingTime;\n    }\n  });\n};\n","import { logMetric } from './log';\nimport { fcp, fcpEntryName, lcp } from './metrics';\nimport { perfObservers } from './observeInstances';\nimport { po, poDisconnect } from './performanceObserver';\nimport { initTotalBlockingTime } from './totalBlockingTime';\nimport { IPerformanceEntry } from './types';\n\n/**\n * First Paint is essentially the paint after which\n * the biggest above-the-fold layout change has happened.\n */\nexport const initFirstPaint = (performanceEntries: IPerformanceEntry[]) => {\n  performanceEntries.forEach(entry => {\n    if (entry.name === 'first-paint') {\n      logMetric(entry.startTime, 'fp');\n    } else if (entry.name === fcpEntryName) {\n      fcp.value = entry.startTime;\n      logMetric(fcp.value, 'fcp');\n      perfObservers[4] = po('longtask', initTotalBlockingTime);\n      poDisconnect(0);\n    }\n  });\n};\n\nexport const initLargestContentfulPaint = (\n  performanceEntries: IPerformanceEntry[],\n) => {\n  const lastEntry = performanceEntries.pop();\n  if (lastEntry) {\n    lcp.value = lastEntry.renderTime || lastEntry.loadTime;\n  }\n};\n\nexport const initElementTiming = (\n  performanceEntries: IPerformanceEntry[],\n) => {\n  performanceEntries.forEach(entry => {\n    if (entry.identifier) {\n      logMetric(entry.startTime, entry.identifier);\n    }\n  });\n};\n","import { config } from './config';\nimport { logData } from './log';\nimport { rt } from './metrics';\nimport { IPerformanceEntry } from './types';\n\nexport const initResourceTiming = (performanceEntries: IPerformanceEntry[]) => {\n  performanceEntries.forEach(entry => {\n    if (config.isResourceTiming) {\n      logData('resourceTiming', entry);\n    }\n    if (entry.decodedBodySize && entry.initiatorType) {\n      const bodySize = entry.decodedBodySize / 1000;\n      rt.value[entry.initiatorType] += bodySize;\n      rt.value.total += bodySize;\n    }\n  });\n};\n","import { config } from './config';\nimport { initLayoutShift } from './cumulativeLayoutShift';\nimport { initFirstInputDelay } from './firstInput';\nimport { logMetric } from './log';\nimport { cls, lcp, tbt } from './metrics';\nimport { perfObservers } from './observeInstances';\nimport {\n  initElementTiming,\n  initFirstPaint,\n  initLargestContentfulPaint,\n} from './paint';\nimport { po, poDisconnect } from './performanceObserver';\nimport { initResourceTiming } from './resourceTiming';\n\nexport const initPerformanceObserver = (): void => {\n  perfObservers[0] = po('paint', initFirstPaint);\n  // FID needs to be initialized as soon as Perfume is available\n  // DataConsumption resolves after FID is triggered\n  perfObservers[1] = po('first-input', initFirstInputDelay);\n  perfObservers[2] = po('largest-contentful-paint', initLargestContentfulPaint);\n  // Collects KB information related to resources on the page\n  if (config.isResourceTiming) {\n    po('resource', initResourceTiming);\n  }\n  perfObservers[3] = po('layout-shift', initLayoutShift);\n  if (config.isElementTiming) {\n    po('element', initElementTiming);\n  }\n};\n\nexport const disconnectPerfObserversHidden = (): void => {\n  if (perfObservers[2]) {\n    logMetric(lcp.value, `lcpFinal`);\n    poDisconnect(2);\n  }\n  if (perfObservers[3]) {\n    if (typeof perfObservers[3].takeRecords === 'function') {\n      perfObservers[3].takeRecords();\n    }\n    logMetric(cls.value, `clsFinal`);\n    poDisconnect(3);\n  }\n  if (perfObservers[4]) {\n    logMetric(tbt.value, `tbtFinal`);\n    poDisconnect(4);\n  }\n};\n","import { logData } from './log';\nimport { convertToKB } from './utils';\n\n/**\n * The estimate() method of the StorageManager interface asks the Storage Manager\n * for how much storage the app takes up (usage),\n * and how much space is available (quota).\n */\nexport const reportStorageEstimate = (storageInfo: StorageEstimate) => {\n  const estimateUsageDetails =\n    'usageDetails' in storageInfo ? (storageInfo as any).usageDetails : {};\n  logData('storageEstimate', {\n    quota: convertToKB((storageInfo as any).quota),\n    usage: convertToKB((storageInfo as any).usage),\n    caches: convertToKB(estimateUsageDetails.caches),\n    indexedDB: convertToKB(estimateUsageDetails.indexedDB),\n    serviceWorker: convertToKB(estimateUsageDetails.serviceWorkerRegistrations),\n  });\n};\n","/*!\n * Perfume.js v5.3.0 (http://zizzamia.github.io/perfume)\n * Copyright 2020 Leonardo Zizzamia (https://github.com/Zizzamia/perfume.js/graphs/contributors)\n * Licensed under MIT (https://github.com/Zizzamia/perfume.js/blob/master/LICENSE)\n * @license\n */\nimport { config } from './config';\nimport { D, W, WN, WP } from './constants';\nimport { getNavigationTiming } from './getNavigationTiming';\nimport { getNetworkInformation } from './getNetworkInformation';\nimport { isPerformanceSupported } from './isSupported';\nimport { logData } from './log';\nimport { performanceMeasure } from './measure';\nimport { metrics } from './metrics';\nimport {\n  disconnectPerfObserversHidden,\n  initPerformanceObserver,\n} from './observe';\nimport { didVisibilityChange, visibility } from './onVisibilityChange';\nimport { reportStorageEstimate } from './storageEstimate';\nimport { IPerfumeOptions } from './types';\nimport { roundByTwo } from './utils';\n\nexport default class Perfume {\n  v = '5.3.0';\n\n  constructor(options: IPerfumeOptions = {}) {\n    // Extend default config with external options\n    config.analyticsTracker = options.analyticsTracker;\n    config.isResourceTiming = !!options.resourceTiming;\n    config.isElementTiming = !!options.elementTiming;\n    config.maxTime = options.maxMeasureTime || config.maxTime;\n\n    // Exit from Perfume when basic Web Performance APIs aren't supported\n    if (!isPerformanceSupported()) {\n      return;\n    }\n    // Checks if use Performance or the EmulatedPerformance instance\n    if ('PerformanceObserver' in W) {\n      initPerformanceObserver();\n    }\n\n    // Init visibilitychange listener\n    if (typeof D.hidden !== 'undefined') {\n      // Opera 12.10 and Firefox 18 and later support\n      D.addEventListener(\n        'visibilitychange',\n        didVisibilityChange.bind(this, disconnectPerfObserversHidden),\n      );\n    }\n    // Log Navigation Timing\n    logData('navigationTiming', getNavigationTiming());\n    // Log Network Information\n    logData('networkInformation', getNetworkInformation());\n    // Let's estimate our storage capacity\n    if (WN && WN.storage && typeof WN.storage.estimate === 'function') {\n      WN.storage.estimate().then(reportStorageEstimate);\n    }\n  }\n\n  /**\n   * Start performance measurement\n   */\n  start(markName: string): void {\n    if (!isPerformanceSupported() || metrics[markName]) {\n      return;\n    }\n    metrics[markName] = true;\n    // Creates a timestamp in the browser's performance entry buffer\n    WP.mark(`mark_${markName}_start`);\n    // Reset hidden value\n    visibility.isHidden = false;\n  }\n\n  /**\n   * End performance measurement\n   */\n  end(markName: string, customProperties = {}): void {\n    if (!isPerformanceSupported() || !metrics[markName]) {\n      return;\n    }\n    // End Performance Mark\n    WP.mark(`mark_${markName}_end`);\n    delete metrics[markName];\n    logData(\n      markName,\n      roundByTwo(performanceMeasure(markName)),\n      customProperties,\n    );\n  }\n\n  /**\n   * End performance measurement after first paint from the beging of it\n   */\n  endPaint(markName: string, customProperties?: object): void {\n    setTimeout(() => {\n      this.end(markName, customProperties);\n    });\n  }\n\n  /**\n   * Removes the named mark from the browser's performance entry buffer.\n   */\n  clear(markName: string): void {\n    delete metrics[markName];\n    // Mobile Safari v13 and UC Browser v11\n    // don't support clearMarks yet\n    if (!WP.clearMarks) {\n      return;\n    }\n    WP.clearMarks(`mark_${markName}_start`);\n    WP.clearMarks(`mark_${markName}_end`);\n  }\n}\n","import { WP } from './constants';\nimport { isPerformanceSupported } from './isSupported';\nimport { IPerfumeNavigationTiming } from './types';\n\n/**\n * Navigation Timing API provides performance metrics for HTML documents.\n * w3c.github.io/navigation-timing/\n * developers.google.com/web/fundamentals/performance/navigation-and-resource-timing\n */\nexport const getNavigationTiming = (): IPerfumeNavigationTiming => {\n  if (!isPerformanceSupported()) {\n    return {};\n  }\n  // There is an open issue to type correctly getEntriesByType\n  // github.com/microsoft/TypeScript/issues/33866\n  const n = WP.getEntriesByType('navigation')[0] as any;\n  // In Safari version 11.2 Navigation Timing isn't supported yet\n  if (!n) {\n    return {};\n  }\n  const responseStart = n.responseStart;\n  const responseEnd = n.responseEnd;\n  // We cache the navigation time for future times\n  return {\n    // fetchStart marks when the browser starts to fetch a resource\n    // responseEnd is when the last byte of the response arrives\n    fetchTime: responseEnd - n.fetchStart,\n    // Service worker time plus response time\n    workerTime: n.workerStart > 0 ? responseEnd - n.workerStart : 0,\n    // Request plus response time (network only)\n    totalTime: responseEnd - n.requestStart,\n    // Response time only (download)\n    downloadTime: responseEnd - responseStart,\n    // Time to First Byte (TTFB)\n    timeToFirstByte: responseStart - n.requestStart,\n    // HTTP header size\n    headerSize: n.transferSize - n.encodedBodySize || 0,\n    // Measuring DNS lookup time\n    dnsLookupTime: n.domainLookupEnd - n.domainLookupStart,\n  };\n};\n","import { WP } from './constants';\n\n/**\n * Get the duration of the timing metric or -1\n * if there a measurement has not been made by the User Timing API\n */\nexport const performanceMeasure = (measureName: string): number => {\n  WP.measure(\n    measureName,\n    `mark_${measureName}_start`,\n    `mark_${measureName}_end`,\n  );\n  const entry = WP.getEntriesByName(measureName).pop();\n  if (entry && entry.entryType === 'measure') {\n    return entry.duration;\n  }\n  return -1;\n};\n"],"names":["config","t","i","o","W","window","C","console","D","document","WN","navigator","WP","performance","getDM","deviceMemory","getHC","hardwareConcurrency","isPerformanceSupported","getEntriesByType","now","mark","et","sd","getIsLowEndDevice","getIsLowEndExperience","includes","visibility","u","didVisibilityChange","cb","hidden","isHidden","roundByTwo","num","parseFloat","toFixed","convertToKB","bytes","Math","pow","fcpScore","lcpScore","fidcore","clsScore","tbtScore","webVitalsScore","fp","fcp","lcp","lcpFinal","fid","fidVitals","cls","clsFinal","tbt","tbt5S","tbt10S","tbtFinal","getVitalsScore","measureName","value","reportPerf","data","customProperties","indexOf","analyticsTracker","metricName","eventProperties","navigatorInformation","serviceWorkerStatus","serviceWorker","controller","isLowEndDevice","isLowEndExperience","vitalsScore","requestIdleCallback","timeout","logData","metric","Object","keys","forEach","key","logMetric","duration","duration2Decimal","maxTime","metrics","rt","beacon","css","fetch","img","other","script","total","xmlhttprequest","initLayoutShift","performanceEntries","lastEntry","pop","hadRecentInput","perfObservers","po","eventType","perfObserver","PerformanceObserver","entryList","getEntries","observe","type","buffered","e","warn","poDisconnect","observer","disconnect","initFirstInputDelay","processingStart","startTime","performanceEntry","takeRecords","setTimeout","initTotalBlockingTime","entry","name","blockingTime","initFirstPaint","initLargestContentfulPaint","renderTime","loadTime","initElementTiming","identifier","initResourceTiming","isResourceTiming","decodedBodySize","initiatorType","bodySize","disconnectPerfObserversHidden","reportStorageEstimate","storageInfo","estimateUsageDetails","usageDetails","quota","usage","caches","indexedDB","serviceWorkerRegistrations","options","this","resourceTiming","isElementTiming","elementTiming","maxMeasureTime","addEventListener","bind","n","responseStart","responseEnd","fetchTime","fetchStart","workerTime","workerStart","totalTime","requestStart","downloadTime","timeToFirstByte","headerSize","transferSize","encodedBodySize","dnsLookupTime","domainLookupEnd","domainLookupStart","getNavigationTiming","dataConnection","connection","effectiveType","saveData","downlink","rtt","getNetworkInformation","storage","estimate","then","Perfume","markName","measure","getEntriesByName","entryType","performanceMeasure","_this","end","clearMarks"],"mappings":"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"}